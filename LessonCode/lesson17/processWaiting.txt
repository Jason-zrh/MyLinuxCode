为什么要有进程等待？
1. 之前讲过，子进程退出，父进程如果不管不顾，就可能造成‘僵尸进程’的问题，进而造成内存泄漏。
2. 另外，进程一旦变成僵尸状态，那就刀枪不入，“杀人不眨眼”的kill -9 也无能为力，因为谁也没有办法杀死一个已经死去的进程。
3.最后，父进程派给子进程的任务完成的如何，我们需要知道。如，子进程运行完成，结果对还是不对，或者是否正常退出。

父进程通过进程等待的方式，回收子进程资源，获取子进程退出信息

是什么？
通过系统调用wait/waitpid进行进程等待

wait方法
{
    #include<sys/types.h>
    #include<sys/wait.h>
    pid_t wait(int*status);
    返回值 :成功返回被等待进程pid，失败返回-1。
    参数 :输出型参数，获取子进程退出状态,不关心则可以设置成为NULL
}

waitpid方法
{
    pid_t waitpid(pid_t pid, int *status, int options);

    返回值：当正常返回的时候waitpid返回收集到的子进程的进程ID；
    如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0；
    如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在；

    参数：
        pid: Pid=-1,等待任一个子进程。与wait等效。
             Pid>0.等待其进程ID与pid相等的子进程。
        status: WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）
                WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码）
        options:
                WNOHANG: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进程的ID。
}


status
不能只当作简单的整形来看待，应该当作位图来看待，16位二进制表示的这个数字，低8位（1～8）代表进程是否正常结束，没有异常
高8位（9～16）代表进程是否得到正确结果，即退出码   



非阻塞轮询 + 自己的事情: WNOHANG这个宏可以实现
pid_t waitpid(pid_t pid, int* status, WNOHANG)



