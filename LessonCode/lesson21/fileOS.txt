对于一个未被打开的文件
1. 路径问题
2. 存储问题
3. 获取问题
4. 效率问题


文件 = 文件属性 + 文件内容 -> 磁盘上存储

文件的内容 -> 数据块
文件的属性 -> inode   

Linux中文件的内容和属性是分开存储的!


=======================================================================================================


1. 硬件 -> 磁盘

磁盘可以看作一个逻辑结构，由CHS(C:磁道, H:磁头, S:扇区)来定位存储位置

操作系统中只存了一个扇区数组的下标，成为逻辑地址(LBA)，LBA和CHS之间可以相互转化
如逻辑地址: 28888（数组下标）

磁头: 20000个扇区
磁道: 50个磁道
一个磁道的扇区: 400个扇区

对应: 磁头 = 28888 / 20000 = 1
      磁道 = （28888 % 20000）/ 400 = 22
      扇区 = 8888 - (22 * 400) = 88


=======================================================================================================


2. 文件系统

文件存储在磁盘的扇区，为了管理好大块内存，操作系统将磁盘分成多个小块区域
struct block
{
    int start;
    int end;
}
类似于进程地址空间时管理小块区域的方式，在磁盘的最开始有一个Boot Block用来存储磁盘的分块信息

一个Block Group(块组)中的组成为:
Super_Block -> Group_Descriptor_Table -> Block_Bitmap -> inode_Bitmap -> inode_table -> Data_Blocks

其中:
Data_Blocks是存文件内容的区域，以块的大小呈现，一个块默认为4096bit(4kb)
inode:单个文件的所有属性，128bite，一般来言，一个文件对应一个inode
inode_tabele:很多inode, 每个inode都有唯一的编号
struct inode
{
    // 文件所有属性
    // Linux中，文件属性不包括文件的名字，在Linux中标识文件的是inode编号

    文件类型
    文件权限
    所有者
    所属组
    ACM时间
    引用计数
    inode_number
    
    int block[NUM] // 存数据块
}

Block_Bitmap:是Data_Block的块的使用情况与比特位的映射(位图)，比特位的内容代表对应块的使用情况
inode_Bitmap:比特位的位置和inode的编号对应起来，检测inode是否是有效的


=======================================================================================================






