操作系统层面进程的状态：运行，阻塞，挂起



Linux内核中的进程状态
static const char * const task_state_array[] = 
{
"R (running)", /* 0 */
"S (sleeping)", /* 1 */
"D (disk sleep)", /* 2 */
"T (stopped)", /* 4 */
"t (tracing stop)", /* 8 */
"X (dead)", /* 16 */
"Z (zombie)", /* 32 */
}

R: 就是进程的运行状态
R+代表在前台运行，在运行时不能输其他指令，当运行时带上&，可以在后台运行

S: 睡眠状态，相当于操作系统的阻塞状态

D: 深度睡眠，S状态是浅度睡眠，可以被唤醒或执行操作，如kill -9 PID
   操作系统在极度繁忙的情况下可能会挂掉一些无用的进程，但是在进程向磁盘存储数据的时候可能会失败，为了防治进程数据丢失，在向磁盘传输数据的时候
   该进程会将自己变成D状态， 在D状态下，该进程不会被执行任何操作，直到数据传输完毕，（断电除外）

T: 暂停状态，可以通过kill -19 PID暂停进程， 或通过kill -18 使进程继续进行
   kill -l 可以查看信号
   gdb在调试的时候会把进程的状态调整到t

X: 死亡状态，匹配操作系统的终止态

Z: 僵尸状态，当一个状态死亡的时候，并不会直接进入X状态，而是会先进入僵尸态
   进程一般退出的时候，如果父进程没有主回收，子进程会让自己处于Z状态，进程相关的资源尤其task_struct结构体不能被释放
   如果一直不处理的话，内存将被一直占用，导致内存泄露！
   

父子进程，父进程先退出，子进程的父进程会被改成1号进程（OS）
父进程是1进程----孤儿进程
该进程被系统领养



