共识原理
1.文件 = 内容 + 属性
2.文件分别打开和未打开的文件
3.打开的文件：谁打开？进程！本质上是研究进程和文件的关系
4.没打开的文件：在磁盘上放置，如何被正确的分门别类的放好，方便快速增删查改

文件被打开，应该先被加载到磁盘
进程:被打开的文件 = 1:n
操作系统内部存在大量被打开的文件，要对这些文件进行管理，应该先描述后组织 --- 在内核中，一个被打开的文件都必须要有自己文件对象，包含很多属性
struct file
{
    // ...
}

C文件接口

fopen() -- 打开文件          
fclose() -- 关闭文件
fwrite() -- 写入文件

fopen() -- 'w'写入模式，在每次打开文件的时候都会把文件清空后写入
        -- 'a'也是写入，但是是以追加的形式写入

如果想要向显示器上输出  把文件换成stdout即可 --> Linux下一切皆文件

下面是C语言会自动打开的三个流(文件)
stdin - 一般对应键盘文件
stdout - 显示器文件
stderr - 显示器文件



系统文件的调用
所有的库只要访问硬件程序， 一定要封装系统调用

打开文件的系统接口:

open(const char* pathname, int flags)
// 打开文件的路径， 打开方式，权限设定
open(const char* pathname, int flags, mode_t mode)
当一个文件不存在想要创建文件的时候，必须使用第二个带有三个参数的接口，因为Linux有权限的概念！

访问文件的本质
每次打开一个文件，都会在内核中创建struct file对象，所有的struct file对象都用一个双向循环链表进行管理
struct file
{
    文件的位置
    基本属性：大小，权限，读写位置
    文件内核缓冲区信息
    struct file* next 指针
}

进程打开文件的时候，会将文件的fd存放在PCB的一个数组中，系统调用接口open的返回值就是这个文件的在数组的下标，一般情况下文件的
返回值是从3开始，空出0， 1， 2 -> 分别代表stdin, stdout, stderr，在进程被加载到cpu时这三个流会被自动放进




