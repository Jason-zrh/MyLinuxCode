进程替换指令: execl
做法为:直接用新程序的代码和数据替换老代码数据，并从新程序的入口开始执行


现象:进程替换exec*之后，后面的代码不会被执行， 如果替换失败才会执行后续的代码
     exec*函数，只会有失败返回值，没有成功返回值！！

小知识:Linux中形成的可执行程序，是有自己的格式的，ELF，可执行程序的表头，可执行程序的入口的地址就在表头

exec*一共有7个接口，每个接口的开头都是exec, execute -- 执行

int execl -> "l"代表list，传参方式与命令行中一样，只是将空格换成逗号了
int execlp -> "p"代表PATH，说明该指令会在默认的环境变量中查找指令，不需要自己输入路径
int execle -> "e"代表env环境变量
int execv -> "v"代表vector，传参方式需要自己定义一个char* const argv[]数组
int execvp -> 与execlp相似
int execvpe -> 与execlpv相似

无论是可执行程序，还是脚本，都能跨程序调用
为什么？
因为所有的语言运行起来，本质都是进程！

怎么向子进程中传递环境变量
1.新增变量: 使用getenv()在父进程中设置环境变量
2.彻底替换: 要调用execle, 传递自己的环境变量时，会直接覆盖，而不是追加

